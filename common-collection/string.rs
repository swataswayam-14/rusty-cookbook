// strings are implemented as a collection of bytes

//Creating a New String
//strings are UTF-8 encoded
fn main(){
    //String::from and to_string do the same thing
    let mut s = String::new();

    let data = "hello , party next weekend";
    let mut s1 = data.to_string();

    let mut s2 = "hello guys , lets rock".to_string();

    let mut s3 = String::from("hello , what's up");

    //updating a string
       //The push_str method takes a string slice
    s.push_str("bar");
    println!("s is {s}");
    s1.push_str(&s3);
    println!("s1 is {s1}");
       //The push method takes a single character as a parameter and adds it to the String
    s3.push('l');


    //Concatenation with the + Operator or the format! Macro

    let s4 = s1 + &s2;// note s1 has been moved here and can no longer be used
    //The + operator uses the add method, whose signature looks something like this:

    //fn add(self, s: &str) -> String {


    //the compiler can coerce the &String argument into a &str

    //concatenating multiple strings:

    let a = String::from("hello ");
    let b = String::from("me got a fever");
    let c = " lets meet once I feel better".to_string();
    let abc = a.clone() + &b + &c;
    println!("concatenated string is {}", abc);

    let xyz = format!("{a}-{b}-{c}"); //The format! macro works like println!, but instead of printing the output to the screen, it returns a String with the contents.
    //code generated by the format! macro uses references so that this call doesnâ€™t take ownership of any of its parameters.
    println!("{}", xyz);
}